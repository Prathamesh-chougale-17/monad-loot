// This file is generated by Firebase Studio.
'use server';
/**
 * @fileOverview Generates NFT art based on a text description, saves to MongoDB, and manages generation limits.
 *
 * - generateNftArt - A function that generates NFT art.
 * - GenerateNftArtInput - The input type for the generateNftArt function.
 * - GenerateNftArtOutput - The return type for the generateNftArt function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';
import clientPromise from '@/lib/mongodb';
import type { NftDocument, UserGenerationDoc, LootItem } from '@/types';
import { generateNftFlavorText } from './generate-nft-flavor-text';

const NFT_GENERATION_LIMIT = 3;

const GenerateNftArtInputSchema = z.object({
  nftBaseName: z.string().describe('The base name or theme for the NFT (e.g., "Cosmic Artifact").'),
  userWalletAddress: z.string().describe("The wallet address of the user requesting the NFT generation."),
  userDisplayName: z.string().optional().describe("The display name of the user (e.g., from Farcaster)."),
});
export type GenerateNftArtInput = z.infer<typeof GenerateNftArtInputSchema>;

// Output will be the full LootItem, or an error object
const GenerateNftArtOutputSchema = z.union([
  z.object({
    id: z.string(),
    name: z.string(),
    flavorText: z.string(),
    imageUrl: z.string(),
    timestamp: z.number(),
    ownerAddress: z.string().optional(),
    creatorAddress: z.string().optional(),
    creatorName: z.string().optional(),
  }),
  z.object({ error: z.string(), limitReached: z.boolean().optional() })
]);

export type GenerateNftArtOutput = z.infer<typeof GenerateNftArtOutputSchema>;


export async function generateNftArt(input: GenerateNftArtInput): Promise<GenerateNftArtOutput> {
  return generateNftArtFlow(input);
}

const generateNftArtFlow = ai.defineFlow(
  {
    name: 'generateNftArtFlow',
    inputSchema: GenerateNftArtInputSchema,
    outputSchema: GenerateNftArtOutputSchema,
  },
  async (input) => {
    const { nftBaseName, userWalletAddress, userDisplayName } = input;

    try {
      const mongoClient = await clientPromise;
      const db = mongoClient.db(); // Use your default DB or specify one: mongoClient.db("yourDbName");
      const userGenerationsCollection = db.collection<UserGenerationDoc>('userGenerations');
      const nftsCollection = db.collection<NftDocument>('nfts');

      // 1. Check generation limit
      let userGenerationData = await userGenerationsCollection.findOne({ walletAddress: userWalletAddress });

      if (!userGenerationData) {
        userGenerationData = {
          walletAddress: userWalletAddress,
          generationsUsed: 0,
          nftGenerationLimit: NFT_GENERATION_LIMIT,
        };
        await userGenerationsCollection.insertOne(userGenerationData);
      }

      if (userGenerationData.generationsUsed >= userGenerationData.nftGenerationLimit) {
        return { error: 'NFT generation limit reached for this address.', limitReached: true };
      }

      // 2. Proceed with generation if limit not reached
      const nftName = `Monad ${nftBaseName}`;
      const nftArtDescription = `A unique digital artwork of a ${nftName}, in a ${nftBaseName.toLowerCase().split(' ').pop()} style. Focus on vibrant purples and electric blues.`;
      
      const {media} = await ai.generate({
        model: 'googleai/gemini-2.0-flash-exp',
        prompt: nftArtDescription,
        config: {
          responseModalities: ['TEXT', 'IMAGE'], 
        },
      });
      
      const generatedImageUrl = media.url!;
      if (!generatedImageUrl) {
        throw new Error('Image generation failed to return a URL.');
      }

      // 3. Generate Flavor Text
      const flavorTextResult = await generateNftFlavorText({ 
        nftName, 
        nftDescription: `A unique ${nftBaseName} from the depths of the Monad ecosystem, owned by ${userDisplayName || userWalletAddress}.` 
      });

      // 4. Create NFT Document
      const newNftId = crypto.randomUUID();
      const timestamp = Date.now();

      const nftDocument: NftDocument = {
        nftId: newNftId,
        name: nftName,
        flavorText: flavorTextResult.flavorText,
        imageUrl: generatedImageUrl, // This is the data URI
        timestamp,
        ownerAddress: userWalletAddress, // Initially, creator is the owner
        creatorAddress: userWalletAddress,
        creatorName: userDisplayName,
        theme: nftBaseName,
      };

      // 5. Save NFT to MongoDB
      await nftsCollection.insertOne(nftDocument);

      // 6. Increment generation count
      await userGenerationsCollection.updateOne(
        { walletAddress: userWalletAddress },
        { $inc: { generationsUsed: 1 }, $set: { lastGenerationTimestamp: timestamp } }
      );
      
      // 7. Return the created LootItem structure
      const createdLootItem: LootItem = {
        id: newNftId,
        name: nftName,
        flavorText: flavorTextResult.flavorText,
        imageUrl: generatedImageUrl,
        timestamp,
        ownerAddress: userWalletAddress,
        creatorAddress: userWalletAddress,
        creatorName: userDisplayName,
      };
      return createdLootItem;

    } catch (error: any) {
      console.error('Error in generateNftArtFlow:', error);
      // Check if it's a limit reached error re-thrown or a new one
      if (error.message && error.message.includes('limit reached')) {
        return { error: error.message, limitReached: true };
      }
      return { error: error.message || 'An unexpected error occurred during NFT generation.' };
    }
  }
);
