
// This file is generated by Firebase Studio.
'use server';
/**
 * @fileOverview Saves NFT metadata (with image data URI) to MongoDB and manages generation limits.
 *
 * - generateNftArt - A function that saves NFT metadata.
 * - GenerateNftArtInput - The input type for the generateNftArt function.
 * - GenerateNftArtOutput - The return type for the generateNftArt function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';
import clientPromise from '@/lib/mongodb';
import type { NftDocument, UserGenerationDoc, LootItem } from '@/types';
import { generateNftFlavorText } from './generate-nft-flavor-text';

const NFT_GENERATION_LIMIT = 3;

const GenerateNftArtInputSchema = z.object({
  nftBaseName: z.string().describe('The base name or theme for the NFT (e.g., "Cosmic Artifact").'),
  userWalletAddress: z.string().describe("The wallet address of the user requesting the NFT generation."),
  userDisplayName: z.string().optional().describe("The display name of the user (e.g., from Farcaster)."),
  nftImageDataUri: z.string().describe("The NFT image as a data URI. Format: 'data:<mimetype>;base64,<encoded_data>'."),
  isFreeGeneration: z.boolean().describe("Indicates if this generation is a free one (counts towards limit).")
});
export type GenerateNftArtInput = z.infer<typeof GenerateNftArtInputSchema>;

// Output will be the full LootItem, or an error object
const GenerateNftArtOutputSchema = z.union([
  z.object({
    id: z.string(),
    name: z.string(),
    flavorText: z.string(),
    imageUrl: z.string(), // This will store the data URI
    timestamp: z.number(),
    ownerAddress: z.string().optional(),
    creatorAddress: z.string().optional(),
    creatorName: z.string().optional(),
  }),
  z.object({ error: z.string() }) // Removed limitReached as frontend handles this check primarily
]);

export type GenerateNftArtOutput = z.infer<typeof GenerateNftArtOutputSchema>;


export async function generateNftArt(input: GenerateNftArtInput): Promise<GenerateNftArtOutput> {
  return generateNftArtFlow(input);
}

const generateNftArtFlow = ai.defineFlow(
  {
    name: 'generateNftArtFlow',
    inputSchema: GenerateNftArtInputSchema,
    outputSchema: GenerateNftArtOutputSchema,
  },
  async (input) => {
    const { nftBaseName, userWalletAddress, userDisplayName, nftImageDataUri, isFreeGeneration } = input;

    try {
      const mongoClient = await clientPromise;
      const db = mongoClient.db();
      const userGenerationsCollection = db.collection<UserGenerationDoc>('userGenerations');
      const nftsCollection = db.collection<NftDocument>('nfts');

      // Ensure user generation record exists if it's a free generation that needs to be tracked
      if (isFreeGeneration) {
        let userGenerationData = await userGenerationsCollection.findOne({ walletAddress: userWalletAddress });
        if (!userGenerationData) {
          userGenerationData = {
            walletAddress: userWalletAddress,
            generationsUsed: 0,
            nftGenerationLimit: NFT_GENERATION_LIMIT,
          };
          await userGenerationsCollection.insertOne(userGenerationData);
        }
        // Double-check limit here for safety, though frontend should gate this
        if (userGenerationData.generationsUsed >= userGenerationData.nftGenerationLimit) {
            // This case should ideally not be hit if frontend logic is correct.
            // If it is, it means a free generation was attempted when it shouldn't have been.
            return { error: 'Free generation limit already reached. This attempt was not recorded.' };
        }
      }


      // 2. NFT Name
      const nftName = `Monad ${nftBaseName}`;

      // 3. Generate Flavor Text
      const flavorTextResult = await generateNftFlavorText({
        nftName,
        nftDescription: `A unique ${nftBaseName} from the depths of the Monad ecosystem, created by ${userDisplayName || userWalletAddress}. Its essence captured as an image.`
      });

      // 4. Create NFT Document
      const newNftId = crypto.randomUUID();
      const timestamp = Date.now();

      const nftDocument: NftDocument = {
        nftId: newNftId,
        name: nftName,
        flavorText: flavorTextResult.flavorText,
        imageUrl: nftImageDataUri, // Store the data URI
        timestamp,
        ownerAddress: userWalletAddress, // Initial owner is the creator
        creatorAddress: userWalletAddress,
        creatorName: userDisplayName,
        theme: nftBaseName,
      };

      // 5. Save NFT to MongoDB
      await nftsCollection.insertOne(nftDocument);

      // 6. Increment generation count ONLY if it's a free generation
      if (isFreeGeneration) {
        await userGenerationsCollection.updateOne(
          { walletAddress: userWalletAddress },
          { $inc: { generationsUsed: 1 }, $set: { lastGenerationTimestamp: timestamp } }
        );
      }

      // 7. Return the created LootItem structure
      const createdLootItem: LootItem = {
        id: newNftId,
        name: nftName,
        flavorText: flavorTextResult.flavorText,
        imageUrl: nftImageDataUri, // Return the data URI
        timestamp,
        ownerAddress: userWalletAddress,
        creatorAddress: userWalletAddress,
        creatorName: userDisplayName,
      };
      return createdLootItem;

    } catch (error: any) {
      console.error('Error in generateNftArtFlow:', error);
      return { error: error.message || 'An unexpected error occurred during NFT processing.' };
    }
  }
);
