// This file is generated by Firebase Studio.
'use server';
/**
 * @fileOverview Saves NFT metadata (with pre-generated image URL) to MongoDB and manages generation limits.
 *
 * - generateNftArt - A function that saves NFT metadata.
 * - GenerateNftArtInput - The input type for the generateNftArt function.
 * - GenerateNftArtOutput - The return type for the generateNftArt function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';
import clientPromise from '@/lib/mongodb';
import type { NftDocument, UserGenerationDoc, LootItem } from '@/types';
import { generateNftFlavorText } from './generate-nft-flavor-text';

const NFT_GENERATION_LIMIT = 3;

const GenerateNftArtInputSchema = z.object({
  nftBaseName: z.string().describe('The base name or theme for the NFT (e.g., "Cosmic Artifact").'),
  userWalletAddress: z.string().describe("The wallet address of the user requesting the NFT generation."),
  userDisplayName: z.string().optional().describe("The display name of the user (e.g., from Farcaster)."),
  nftImageUrl: z.string().url().describe("The URL of the NFT image, already uploaded to a hosting service like Edgestore.")
});
export type GenerateNftArtInput = z.infer<typeof GenerateNftArtInputSchema>;

// Output will be the full LootItem, or an error object
const GenerateNftArtOutputSchema = z.union([
  z.object({
    id: z.string(),
    name: z.string(),
    flavorText: z.string(),
    imageUrl: z.string(),
    timestamp: z.number(),
    ownerAddress: z.string().optional(),
    creatorAddress: z.string().optional(),
    creatorName: z.string().optional(),
  }),
  z.object({ error: z.string(), limitReached: z.boolean().optional() })
]);

export type GenerateNftArtOutput = z.infer<typeof GenerateNftArtOutputSchema>;


export async function generateNftArt(input: GenerateNftArtInput): Promise<GenerateNftArtOutput> {
  return generateNftArtFlow(input);
}

const generateNftArtFlow = ai.defineFlow(
  {
    name: 'generateNftArtFlow',
    inputSchema: GenerateNftArtInputSchema,
    outputSchema: GenerateNftArtOutputSchema,
  },
  async (input) => {
    const { nftBaseName, userWalletAddress, userDisplayName, nftImageUrl } = input;

    try {
      const mongoClient = await clientPromise;
      const db = mongoClient.db(); 
      const userGenerationsCollection = db.collection<UserGenerationDoc>('userGenerations');
      const nftsCollection = db.collection<NftDocument>('nfts');

      // 1. Check generation limit
      let userGenerationData = await userGenerationsCollection.findOne({ walletAddress: userWalletAddress });

      if (!userGenerationData) {
        userGenerationData = {
          walletAddress: userWalletAddress,
          generationsUsed: 0,
          nftGenerationLimit: NFT_GENERATION_LIMIT,
        };
        await userGenerationsCollection.insertOne(userGenerationData);
      }

      if (userGenerationData.generationsUsed >= userGenerationData.nftGenerationLimit) {
        return { error: 'NFT generation limit reached for this address.', limitReached: true };
      }

      // 2. NFT Name
      const nftName = `Monad ${nftBaseName}`;
      
      // 3. Generate Flavor Text (Image is already generated and URL provided)
      const flavorTextResult = await generateNftFlavorText({ 
        nftName, 
        nftDescription: `A unique ${nftBaseName} from the depths of the Monad ecosystem, owned by ${userDisplayName || userWalletAddress}. Its essence captured at ${nftImageUrl}` 
      });

      // 4. Create NFT Document
      const newNftId = crypto.randomUUID();
      const timestamp = Date.now();

      const nftDocument: NftDocument = {
        nftId: newNftId,
        name: nftName,
        flavorText: flavorTextResult.flavorText,
        imageUrl: nftImageUrl, // Use the provided Edgestore URL
        timestamp,
        ownerAddress: userWalletAddress, 
        creatorAddress: userWalletAddress,
        creatorName: userDisplayName,
        theme: nftBaseName,
      };

      // 5. Save NFT to MongoDB
      await nftsCollection.insertOne(nftDocument);

      // 6. Increment generation count
      await userGenerationsCollection.updateOne(
        { walletAddress: userWalletAddress },
        { $inc: { generationsUsed: 1 }, $set: { lastGenerationTimestamp: timestamp } }
      );
      
      // 7. Return the created LootItem structure
      const createdLootItem: LootItem = {
        id: newNftId,
        name: nftName,
        flavorText: flavorTextResult.flavorText,
        imageUrl: nftImageUrl,
        timestamp,
        ownerAddress: userWalletAddress,
        creatorAddress: userWalletAddress,
        creatorName: userDisplayName,
      };
      return createdLootItem;

    } catch (error: any) {
      console.error('Error in generateNftArtFlow:', error);
      if (error.message && error.message.includes('limit reached')) {
        return { error: error.message, limitReached: true };
      }
      return { error: error.message || 'An unexpected error occurred during NFT processing.' };
    }
  }
);
